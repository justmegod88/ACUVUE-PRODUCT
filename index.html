<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ACUVUE TORIC 3D MVP</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111a2a;
      --card2:#0f1625;
      --text:#e9eefb;
      --muted:#a9b6d3;
      --accent:#ff2d2d;
      --btn:#1a2742;
      --btnOn:#24365f;
      --warn:#ffcc00;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;}
    #app{position:fixed; inset:0; display:flex; flex-direction:column;}
    header{
      position:sticky; top:0; z-index:5;
      padding:10px 12px 8px;
      background:linear-gradient(180deg, rgba(11,15,23,.98), rgba(11,15,23,.75));
      backdrop-filter: blur(8px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .toprow{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .brand{font-weight:800; letter-spacing:.3px;}
    .pill{font-size:12px; padding:4px 8px; border-radius:999px; background:rgba(255,255,255,.08); color:var(--muted);}
    .toggle{
      margin-top:8px;
      display:flex; gap:8px; width:100%;
    }
    .toggle button{
      flex:1;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 10px;
      border-radius:12px;
      font-weight:700;
    }
    .toggle button.active{
      background:rgba(255,45,45,.18);
      border-color: rgba(255,45,45,.45);
    }

    #stageWrap{position:relative; flex:1; min-height:0;}
    #stage{position:absolute; inset:0;}
    #status{
      position:absolute; left:12px; right:12px; top:12px; z-index:2;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      pointer-events:none;
    }
    .statusChip{
      pointer-events:none;
      background:rgba(17,26,42,.72);
      border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      color:var(--muted);
    }

    /* bottom controls */
    footer{
      position:sticky; bottom:0; z-index:5;
      padding:10px 12px 12px;
      background:linear-gradient(0deg, rgba(11,15,23,.98), rgba(11,15,23,.75));
      backdrop-filter: blur(8px);
      border-top:1px solid rgba(255,255,255,.06);
    }
    .tabs{display:flex; gap:8px;}
    .tabs button{
      flex:1;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:12px 10px;
      border-radius:14px;
      font-weight:800;
    }
    .tabs button.on{background:rgba(36,54,95,.75); border-color:rgba(255,255,255,.16);}
    .tabs button:disabled{opacity:.35}

    .card{
      margin-top:10px;
      background:rgba(17,26,42,.68);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:12px 12px;
    }
    .card h3{margin:0 0 6px 0; font-size:14px;}
    .card p{margin:0; font-size:13px; color:var(--muted); line-height:1.35;}
    .actions{
      margin-top:10px;
      display:flex; gap:8px;
    }
    .actions button{
      flex:1;
      border:1px solid rgba(255,255,255,.10);
      background:var(--btn);
      color:var(--text);
      padding:10px 10px;
      border-radius:12px;
      font-weight:800;
    }
    .actions button.primary{
      background:rgba(255,45,45,.20);
      border-color:rgba(255,45,45,.45);
    }
    .hint{
      margin-top:8px;
      font-size:12px;
      color:rgba(233,238,251,.70);
    }
    .hint span{color:var(--warn); font-weight:800;}
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="toprow">
      <div class="brand">ACUVUE TORIC 3D</div>
      <div class="pill" id="badge">Optician MVP</div>
    </div>
    <div class="toggle" role="tablist" aria-label="제품 선택">
      <button id="btnOneDay" class="active">오아시스 원데이 난시</button>
      <button id="btnMax">오아시스 맥스 난시</button>
    </div>
  </header>

  <div id="stageWrap">
    <div id="status">
      <div class="statusChip" id="chipLeft">⦿ 착용 직후: 축 안정화 진행 중</div>
      <div class="statusChip" id="chipRight">드래그: 회전 · 핀치: 확대</div>
    </div>
    <canvas id="stage"></canvas>
  </div>

  <footer>
    <div class="tabs">
      <button id="tabASD" class="on">ASD</button>
      <button id="tabPVP">PVP</button>
      <button id="tabBL" disabled>BL</button>
    </div>

    <div class="card">
      <h3 id="cardTitle">ASD 디자인</h3>
      <p id="cardBody">
        순목 시 눈꺼풀과 렌즈의 상호작용으로 난시 축이 빠르게 제자리로 안정됩니다.
      </p>
      <div class="actions">
        <button id="btnBlink" class="primary">Blink (ASD)</button>
        <button id="btnBeforeAfter">Before/After</button>
      </div>
      <div class="hint">팁: <span>Blink</span>를 눌러 2~3회 깜박임 후 축이 정렬되는 연출을 확인하세요.</div>
    </div>
  </footer>
</div>

<!-- Three.js (module) -->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

  // ---------- DOM ----------
  const canvas = document.getElementById('stage');
  const chipLeft = document.getElementById('chipLeft');
  const btnOneDay = document.getElementById('btnOneDay');
  const btnMax = document.getElementById('btnMax');

  const tabASD = document.getElementById('tabASD');
  const tabPVP = document.getElementById('tabPVP');
  const tabBL  = document.getElementById('tabBL');

  const cardTitle = document.getElementById('cardTitle');
  const cardBody  = document.getElementById('cardBody');

  const btnBlink = document.getElementById('btnBlink');
  const btnBeforeAfter = document.getElementById('btnBeforeAfter');

  // ---------- Scene ----------
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b0f17, 3.5, 10);

  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 50);
  camera.position.set(0, 0.7, 4.2);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  controls.minDistance = 2.4;
  controls.maxDistance = 6.5;
  controls.rotateSpeed = 0.8;

  // Lights
  const hemi = new THREE.HemisphereLight(0xcfe7ff, 0x17223a, 0.9);
  scene.add(hemi);

  const key = new THREE.DirectionalLight(0xffffff, 0.9);
  key.position.set(2.8, 2.2, 2.2);
  scene.add(key);

  const rim = new THREE.DirectionalLight(0x7fb3ff, 0.55);
  rim.position.set(-3, 1.0, -2.0);
  scene.add(rim);

  // ---------- Eye (simple sphere + iris) ----------
  const group = new THREE.Group();
  scene.add(group);

  const eyeGeo = new THREE.SphereGeometry(1.05, 64, 64);
  const eyeMat = new THREE.MeshStandardMaterial({
    color: 0xf2f5ff,
    roughness: 0.35,
    metalness: 0.0,
  });
  const eye = new THREE.Mesh(eyeGeo, eyeMat);
  group.add(eye);

  const irisGeo = new THREE.CircleGeometry(0.38, 64);
  const irisMat = new THREE.MeshStandardMaterial({ color: 0x2a6b7a, roughness: 0.8 });
  const iris = new THREE.Mesh(irisGeo, irisMat);
  iris.position.set(0, 0, 1.02);
  group.add(iris);

  const pupilGeo = new THREE.CircleGeometry(0.14, 64);
  const pupilMat = new THREE.MeshStandardMaterial({ color: 0x0b0f17, roughness: 0.9 });
  const pupil = new THREE.Mesh(pupilGeo, pupilMat);
  pupil.position.set(0, 0, 1.03);
  group.add(pupil);

  // ---------- Toric Lens (transparent disc) ----------
  const lensGeo = new THREE.CircleGeometry(0.88, 96);
  const lensMat = new THREE.MeshPhysicalMaterial({
    color: 0x7fd1ff,
    transparent: true,
    opacity: 0.18,
    roughness: 0.18,
    transmission: 0.9,     // glass-like
    thickness: 0.12,
    ior: 1.33,
    clearcoat: 0.6,
    clearcoatRoughness: 0.15
  });
  const lens = new THREE.Mesh(lensGeo, lensMat);
  lens.position.set(0, 0, 1.10);
  group.add(lens);

  // Toric axis marker (line)
  const markerMat = new THREE.LineBasicMaterial({ color: 0xfff2a6, transparent:true, opacity:0.9 });
  const markerPts = [ new THREE.Vector3(-0.70, 0.0, 1.105), new THREE.Vector3(0.70, 0.0, 1.105) ];
  const markerGeo = new THREE.BufferGeometry().setFromPoints(markerPts);
  const marker = new THREE.Line(markerGeo, markerMat);
  group.add(marker);

  // Small tick on top (to make rotation obvious)
  const tickGeo = new THREE.BoxGeometry(0.06, 0.18, 0.02);
  const tickMat = new THREE.MeshStandardMaterial({ color: 0xffd15a, roughness: 0.4 });
  const tick = new THREE.Mesh(tickGeo, tickMat);
  tick.position.set(0, 0.78, 1.11);
  group.add(tick);

  // ---------- Eyelid (blink) ----------
  // Simple "lid" plane that moves down/up (MVP)
  const lidGeo = new THREE.PlaneGeometry(2.6, 1.6);
  const lidMat = new THREE.MeshStandardMaterial({
    color: 0x0b0f17,
    transparent: true,
    opacity: 0.92,
    side: THREE.DoubleSide
  });
  const lid = new THREE.Mesh(lidGeo, lidMat);
  lid.position.set(0, 1.2, 1.25);
  lid.rotation.x = Math.PI * 0.02;
  group.add(lid);

  // ---------- Blue-light rays (MAX only) ----------
  const raysGroup = new THREE.Group();
  scene.add(raysGroup);
  raysGroup.visible = false;

  function makeRay(angleDeg){
    const g = new THREE.CylinderGeometry(0.01, 0.06, 3.0, 10, 1, true);
    const m = new THREE.MeshStandardMaterial({ color: 0x4aa3ff, transparent:true, opacity:0.35, emissive:0x2255aa });
    const ray = new THREE.Mesh(g, m);
    ray.rotation.z = THREE.MathUtils.degToRad(angleDeg);
    ray.position.set(-1.9, 0.2, 1.1);
    ray.rotation.x = Math.PI/2;
    return ray;
  }
  const ray1 = makeRay(8);
  const ray2 = makeRay(-8);
  raysGroup.add(ray1, ray2);

  // ---------- State ----------
  let product = 'oneday'; // 'oneday' | 'max'
  let tab = 'ASD';        // 'ASD' | 'PVP' | 'BL'
  let isBlinking = false;

  // Toric axis simulation: start misaligned, then align to 0
  const MISALIGN = THREE.MathUtils.degToRad(18);
  let axisAngle = MISALIGN;
  let axisTarget = MISALIGN;

  // before/after toggle
  let afterMode = false;

  // Apply axis angle to marker + tick + lens
  function applyAxis(angle){
    // rotate around Z axis (screen-facing axis)
    lens.rotation.z = angle;
    marker.rotation.z = angle;
    tick.rotation.z = angle;
  }
  applyAxis(axisAngle);

  // ---------- UI helpers ----------
  function setProduct(next){
    product = next;

    btnOneDay.classList.toggle('active', product === 'oneday');
    btnMax.classList.toggle('active', product === 'max');

    // BL tab enabled only for MAX
    tabBL.disabled = (product !== 'max');
    if (tab === 'BL' && product !== 'max') setTab('ASD');

    // Badge
    document.getElementById('badge').textContent =
      (product === 'max') ? 'Optician MVP · MAX' : 'Optician MVP · 1-Day';

    // small visual: MAX slightly warmer lens tint (just for demo)
    lensMat.color.set(product === 'max' ? 0x8be1ff : 0x7fd1ff);

    // reset BL visuals
    raysGroup.visible = (tab === 'BL' && product === 'max');
  }

  function setTab(next){
    tab = next;
    tabASD.classList.toggle('on', tab === 'ASD');
    tabPVP.classList.toggle('on', tab === 'PVP');
    tabBL.classList.toggle('on',  tab === 'BL');

    if (tab === 'ASD'){
      cardTitle.textContent = 'ASD 디자인';
      cardBody.textContent = '순목 시 눈꺼풀과 렌즈의 상호작용으로 난시 축이 빠르게 제자리로 안정됩니다.';
      btnBlink.style.display = '';
      btnBeforeAfter.style.display = '';
      raysGroup.visible = false;
      markerMat.opacity = 0.9;
    } else if (tab === 'PVP'){
      cardTitle.textContent = 'PVP 습윤 인자';
      cardBody.textContent = 'PVP 습윤 인자가 표면 젖음성을 유지하도록 도와 편안함에 기여합니다. (MVP: 표면 강조 연출)';
      btnBlink.style.display = 'none';
      btnBeforeAfter.style.display = 'none';
      raysGroup.visible = false;
      markerMat.opacity = 0.35;
      // visual: slightly increase gloss/transmission to imply wet surface
      lensMat.opacity = 0.16;
      lensMat.clearcoat = 0.85;
    } else if (tab === 'BL'){
      cardTitle.textContent = '블루라이트 (MAX)';
      cardBody.textContent = '블루라이트가 눈으로 들어오는 경로 중 일부가 렌즈에서 감소/필터링되는 연출을 확인합니다. (MVP: 광선 + 감쇠)';
      btnBlink.style.display = 'none';
      btnBeforeAfter.style.display = 'none';
      raysGroup.visible = (product === 'max');
      markerMat.opacity = 0.35;
      // visual: slightly warm lens tint to cue filtering (demo only)
      lensMat.color.set(0x98e6ff);
    }
  }

  function setStatus(text){
    chipLeft.textContent = text;
  }

  // ---------- ASD interactions ----------
  function setBefore(){
    afterMode = false;
    axisTarget = MISALIGN;
    setStatus('⦿ 착용 직후: 축 안정화 진행 중');
  }

  function setAfter(){
    afterMode = true;
    axisTarget = 0;
    setStatus('⦿ 순목 후: 축 안정화 완료');
  }

  btnBlink.addEventListener('click', async () => {
    if (isBlinking) return;
    isBlinking = true;
    setStatus('⦿ Blink 중: 축 안정화 진행…');

    // blink 3 times
    const blinks = 3;
    for (let i=0;i<blinks;i++){
      await blinkOnce(170);
      // during blink, nudge axis toward 0 (simulate stabilization)
      axisTarget = 0;
      await sleep(70);
    }

    setAfter();
    isBlinking = false;
  });

  btnBeforeAfter.addEventListener('click', () => {
    if (!afterMode) setAfter();
    else setBefore();
  });

  async function blinkOnce(durationMs=160){
    // lid down
    await animateValue(1.2, 0.15, durationMs*0.55, (v)=>{ lid.position.y = v; });
    // lid up
    await animateValue(0.15, 1.2, durationMs*0.45, (v)=>{ lid.position.y = v; });
  }

  // ---------- UI event bindings ----------
  btnOneDay.addEventListener('click', ()=> setProduct('oneday'));
  btnMax.addEventListener('click', ()=> setProduct('max'));

  tabASD.addEventListener('click', ()=> { setTab('ASD'); lensMat.opacity = 0.18; lensMat.clearcoat = 0.6; });
  tabPVP.addEventListener('click', ()=> setTab('PVP'));
  tabBL.addEventListener('click', ()=> { if (product==='max') setTab('BL'); });

  // ---------- animation helpers ----------
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  function animateValue(from, to, ms, onUpdate){
    return new Promise(resolve=>{
      const t0 = performance.now();
      function step(t){
        const p = Math.min((t - t0)/ms, 1);
        // easeInOut
        const e = p<0.5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2;
        const v = from + (to-from)*e;
        onUpdate(v);
        if (p<1) requestAnimationFrame(step);
        else resolve();
      }
      requestAnimationFrame(step);
    });
  }

  // ---------- resize ----------
  function resize(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  // ---------- render loop ----------
  const clock = new THREE.Clock();

  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.033);

    controls.update();

    // axis smooth approach
    const speed = 2.2; // higher = faster alignment
    axisAngle = THREE.MathUtils.lerp(axisAngle, axisTarget, 1 - Math.exp(-speed * dt));
    applyAxis(axisAngle);

    // subtle floating
    group.position.y = Math.sin(performance.now()*0.0007)*0.02;

    // BL rays attenuation (MVP)
    if (tab === 'BL' && product === 'max'){
      const t = performance.now()*0.0012;
      ray1.material.opacity = 0.22 + 0.10*Math.sin(t);
      ray2.material.opacity = 0.22 + 0.10*Math.cos(t*1.1);
    }

    renderer.render(scene, camera);
  }

  // init
  resize();
  setProduct('oneday');
  setTab('ASD');
  setBefore();
  animate();
</script>
</body>
</html>
