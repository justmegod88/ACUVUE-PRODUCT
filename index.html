<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ACUVUE GLB Viewer (Optician)</title>

  <style>
    html,body{height:100%;margin:0;background:#081625;overflow:hidden;font-family:-apple-system,system-ui;}
    model-viewer{width:100vw;height:100vh;background:transparent;display:block;}

    /* 상단 미션 카드 */
    #missionBar{
      position:fixed; left:12px; right:12px; top:12px; z-index:40;
      display:flex; gap:10px; align-items:stretch;
      pointer-events:auto;
    }
    .missionCard{
      flex:1;
      padding:12px 12px;
      border-radius:16px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      color:#eaf2ff;
      backdrop-filter: blur(8px);
      min-height:86px;
      box-sizing:border-box;

      -webkit-tap-highlight-color: transparent;
      user-select:none;
      cursor:pointer;
      transition: transform .08s ease, background .18s ease, border-color .18s ease;
      position:relative;
    }
    .missionCard:active{ transform: scale(.99); }

    .missionCard.on{
      background:rgba(0,255,140,.12);
      border-color:rgba(0,255,140,.35);
    }

    .missionCard.done::after{
      content:"완료";
      position:absolute;
      right:10px; top:10px;
      font-size:11px;
      font-weight:900;
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,255,140,.16);
      border:1px solid rgba(0,255,140,.35);
      color:rgba(234,242,255,.98);
      backdrop-filter: blur(6px);
    }

    .missionNo{font-weight:900;opacity:.85;font-size:14px;margin-bottom:6px;}
    .missionTitle{font-weight:900;font-size:16px;margin-bottom:6px;}
    .missionDesc{font-size:12.5px;line-height:1.35;opacity:.88;white-space:pre-line;}

    /* 하단 버튼 */
    #bottomBtns{
      position:fixed;left:12px;right:12px;bottom:12px;z-index:50;
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    }
    .btn{
      flex:1;min-width:140px;
      padding:12px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#eaf2ff;font-weight:900;font-size:13px;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(8px);
    }
    .btn.primary{ background:rgba(0,255,140,.12); border-color:rgba(0,255,140,.35); }

    /* 작은 원형 ↺ 버튼 */
    #btnReset{
      width:46px;height:46px;min-width:46px;flex:0 0 auto;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#eaf2ff;
      font-weight:900;
      font-size:16px;
      display:flex;align-items:center;justify-content:center;
      backdrop-filter: blur(8px);
      -webkit-tap-highlight-color: transparent;
    }

    /* =========================
       ✅ 블루라이트: 상태 pill + 광선(투과/꺾임) + 설명/미션
       ========================= */

    /* ✅ on/off 토글 pill -> "선택형 세그먼트" */
    #bluePill{
      position:fixed;
      right:14px;
      bottom:210px;
      z-index:72;
      display:none;

      padding:6px;
      border-radius:999px;
      background:rgba(0,0,0,.70);
      border:1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(10px);
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      box-shadow:0 18px 60px rgba(0,0,0,.35);

      display:flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }
    .blueSegBtn{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:#eaf2ff;
      font-weight:900;
      font-size:13px;
      letter-spacing:.2px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .blueSegBtn:active{ transform:scale(.98); }
    .blueSegBtn.on{
      background:rgba(0,255,140,.14);
      border-color:rgba(0,255,140,.40);
    }

    /* ✅ 광선 레이어 */
    #blueRayLayer{
      position:fixed;
      inset:0;
      z-index:57;
      pointer-events:none;
      display:none;
    }
    #blueRaySvg{
      width:100%;
      height:100%;
      display:block;
    }

    /* ✅ OFF일 때: 렌즈 뒤쪽 약한 그라데이션 */
    #blueBackGlow{
      position:fixed;
      inset:0;
      z-index:56;
      pointer-events:none;
      display:none;
      background:
        radial-gradient(35% 22% at 66% 52%,
          rgba(0,200,255,.18) 0%,
          rgba(0,200,255,.10) 22%,
          rgba(0,200,255,.06) 38%,
          rgba(0,200,255,0) 62%);
      filter: blur(1px);
      opacity:.95;
    }

    /* ✅ 하단 설명/미션 패널 */
    #blueInfo{
      position:fixed;
      left:12px;
      right:12px;
      bottom:92px;
      z-index:71;
      display:none;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
      box-shadow:0 18px 60px rgba(0,0,0,.35);
      overflow:hidden;
    }
    #blueInfoTop{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      color:#eaf2ff;
      font-weight:900;
      font-size:13px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    #blueInfoTop b{ font-weight:900; }
    #blueInfoTop b .pct{ color:rgba(0,255,140,.95); }

    #blueInfoBody{
      padding:10px 12px;
      color:rgba(234,242,255,.88);
      font-size:12.5px;
      line-height:1.35;
    }

    #blueInfoMission{
      padding:9px 12px;
      border-top:1px solid rgba(255,255,255,.10);
      color:rgba(234,242,255,.92);
      font-size:12.5px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    #blueInfoMission .left{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      flex:1 1 auto;
    }
    #blueInfoMission .confirm{
      color:#eaf2ff;
      font-weight:900;
      opacity:.95;
      cursor:pointer;
      user-select:none;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      -webkit-tap-highlight-color: transparent;
      flex:0 0 auto;
      white-space:nowrap;
      display:none;
    }
    #blueInfoMission .confirm:active{ transform:scale(.98); }

    /* ========================= */

    /* ASD 오버레이 */
    #asdOverlay{
      position:fixed; inset:0; z-index:80;
      display:none;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      align-items:center; justify-content:center;
      padding:18px;
      box-sizing:border-box;
    }
    #asdOverlay.show{ display:flex; }
    #asdCard{
      width:min(920px, 96vw);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(10,18,30,.62);
      overflow:hidden;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      position:relative;
    }
    #asdCard img{ width:100%; height:auto; display:block; background:rgba(255,255,255,.04); }
    #asdClose{
      position:absolute; right:10px; top:10px;
      width:38px; height:38px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:#eaf2ff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      z-index:6;
    }
    #asdHint{
      padding:10px 12px;
      color:#eaf2ff;
      font-size:12.5px;
      opacity:.9;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
    }
    #asdHint button{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:#eaf2ff;
      font-weight:900;
      font-size:12px;
      padding:8px 10px;
      border-radius:12px;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(8px);
      cursor:pointer;
      flex:0 0 auto;
      white-space:nowrap;
    }
    #asdHint button:active{ transform:scale(.98); }

    #asdScene{
      position:relative;
      width:100%;
      background:rgba(255,255,255,.04);
      overflow:hidden;
      aspect-ratio: 16/9;
      min-height: 320px;
    }
    #asdEyeMV{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      background:transparent;
      pointer-events:none;
      transform: translateY(18px);
    }
    #asdLensImg{
      position:absolute;
      left:50%;
      top:53%;
      width:70%;
      transform:translate(-50%,-50%) rotate(20deg);
      transform-origin:50% 50%;
      opacity:.78;
      mix-blend-mode: screen;
      filter:saturate(1.08) contrast(1.06);
      pointer-events:none;
      will-change: transform;
    }
    #asdLensRim{
      position:absolute;
      left:50%;
      top:53%;
      width:70%;
      height:70%;
      transform:translate(-50%,-50%);
      border-radius:999px;
      pointer-events:none;
      box-shadow:
        0 0 0 1px rgba(255,255,255,.12),
        0 18px 46px rgba(0,0,0,.22),
        inset 0 0 24px rgba(255,255,255,.10);
      opacity:.55;
      mix-blend-mode: screen;
    }
    #asdMaskShade{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(110% 70% at 50% 18%,
          rgba(0,0,0,.50) 0%,
          rgba(0,0,0,.28) 30%,
          rgba(0,0,0,0) 58%),
        radial-gradient(110% 70% at 50% 90%,
          rgba(0,0,0,.46) 0%,
          rgba(0,0,0,.22) 32%,
          rgba(0,0,0,0) 60%);
      mix-blend-mode: multiply;
      opacity:.9;
    }
    #asdBlinkLid{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.62);
      transform:scaleY(0);
      transform-origin:center;
      opacity:0;
      pointer-events:none;
      will-change:transform,opacity;
      z-index:4;
    }
    #asdBlinkBtn{
      position:absolute;
      right:14px;
      bottom:14px;
      width:54px;
      height:54px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.26);
      background:rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
      color:#0b1b2e;
      font-weight:900;
      font-size:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      cursor:pointer;
      box-shadow:0 10px 28px rgba(0,0,0,.20);
      z-index:5;
    }
    #asdBlinkBtn:active{ transform:scale(.95); }
    #asdRotateBtn{
      position:absolute;
      right:76px;
      bottom:14px;
      width:54px;
      height:54px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.26);
      background:rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
      color:#0b1b2e;
      font-weight:900;
      font-size:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      cursor:pointer;
      box-shadow:0 10px 28px rgba(0,0,0,.20);
      z-index:5;
    }
    #asdRotateBtn:active{ transform:scale(.95); }
    #asdAngleBadge{
      position:absolute;
      left:14px;
      bottom:18px;
      color:rgba(234,242,255,.88);
      font-size:12px;
      font-weight:900;
      text-shadow:0 2px 10px rgba(0,0,0,.35);
      background:rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:6px 10px;
      backdrop-filter: blur(8px);
      z-index:5;
    }

    /* PVP 큰 원형 */
    #pvpBig{
      position:fixed;
      left:50%;
      top:49%;
      transform:translate(-50%,-50%);
      width:min(72vw, 520px);
      height:min(72vw, 520px);
      border-radius:999px;
      z-index:56;
      display:none;
      pointer-events:none;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(8px);
      overflow:hidden;
      box-shadow:0 18px 70px rgba(0,0,0,.35);
    }
    #pvpBig.show{ display:block; }
    #pvpBig img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      border-radius:999px;
      filter:saturate(1.05) contrast(1.02);
    }
    #pvpBig::after{
      content:"";
      position:absolute; inset:0;
      border-radius:999px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      pointer-events:none;
    }

    /* PVP 하단 설명 */
    #pvpOverlay{
      position:fixed; left:12px; right:12px; bottom:92px; z-index:60;
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px 10px;
      display:none;
      gap:10px;
      align-items:center;
      backdrop-filter: blur(10px);
    }
    #pvpOverlay.show{ display:flex; }
    #pvpOverlay img{
      width:88px;height:88px;object-fit:cover;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
    }
    #pvpText{color:#eaf2ff;font-size:12.5px;line-height:1.35; flex:1 1 auto;}
    #pvpTitle{font-weight:900;margin-bottom:2px;}
    #hint{opacity:.85;}

    /* ✅ PVP 확인 버튼 */
    #pvpConfirm{
      color:#eaf2ff;
      font-weight:900;
      opacity:.95;
      cursor:pointer;
      user-select:none;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      -webkit-tap-highlight-color: transparent;
      flex:0 0 auto;
      white-space:nowrap;
      display:none;
    }
    #pvpConfirm:active{ transform:scale(.98); }

    /* 두께 그래프(가로형) */
    #thicknessBar{
      position:fixed;
      left:12px;
      right:12px;
      bottom:92px;
      z-index:67;
      display:none;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.38);
      backdrop-filter: blur(10px);
      padding:10px 12px 12px;
      box-sizing:border-box;
      box-shadow:0 18px 60px rgba(0,0,0,.35);
    }
    #thicknessBar.show{ display:block; }

    #thHeader{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      margin-bottom:8px;
    }
    #thTitle{
      color:#eaf2ff;
      font-weight:900;
      font-size:12.5px;
      letter-spacing:.2px;
      opacity:.95;
    }
    #thUnit{
      color:rgba(234,242,255,.70);
      font-size:11px;
      font-weight:700;
      letter-spacing:.1px;
    }

    #gradRow{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .tickLabel{
      width:46px;
      text-align:right;
      color:rgba(234,242,255,.78);
      font-size:11px;
      font-weight:700;
      letter-spacing:.1px;
      flex:0 0 auto;
    }

    #gradWrap{
      position:relative;
      flex:1 1 auto;
      height:14px;
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      box-shadow: inset 0 0 12px rgba(0,0,0,.35);
    }

    #grad{
      position:absolute; inset:0;
      background:linear-gradient(90deg,
        rgba(140,  0,255,1) 0%,
        rgba(  0, 90,255,1) 17%,
        rgba(  0,200,255,1) 32%,
        rgba(  0,255,150,1) 48%,
        rgba(150,255,  0,1) 64%,
        rgba(255,220,  0,1) 78%,
        rgba(255,120,  0,1) 90%,
        rgba(255, 50, 50,1) 100%
      );
      opacity:.92;
      filter:saturate(1.05) contrast(1.05);
    }

    #gradShine{
      position:absolute; inset:0;
      background:linear-gradient(180deg,
        rgba(255,255,255,.22) 0%,
        rgba(255,255,255,0) 55%,
        rgba(0,0,0,.18) 100%
      );
      mix-blend-mode: overlay;
      opacity:.55;
      pointer-events:none;
    }

    .mark{
      position:absolute;
      top:-6px;
      width:1px;
      height:26px;
      background:rgba(255,255,255,.18);
    }
    .mark strong{
      position:absolute;
      top:18px;
      left:50%;
      transform:translateX(-50%);
      font-size:10px;
      color:rgba(234,242,255,.70);
      font-weight:700;
      white-space:nowrap;
    }
    .m0{ left:0%; }
    .m25{ left:25%; }
    .m50{ left:50%; }
    .m75{ left:75%; }
    .m100{ left:100%; }

    #thHint{ display:none; }
  </style>
</head>

<body>
  <!-- ✅ 미션 카드 -->
  <div id="missionBar">
    <div id="missionASD" class="missionCard" role="button" tabindex="0" aria-label="ASD 기술 보기">
      <div class="missionNo">01</div>
      <div class="missionTitle">ASD 기술</div>
      <div class="missionDesc">카드를 눌러 확인</div>
    </div>
    <div id="missionPVP" class="missionCard" role="button" tabindex="0" aria-label="PVP 보기">
      <div class="missionNo">02</div>
      <div class="missionTitle">눈물 안정화</div>
      <div class="missionDesc">카드를 눌러 확인</div>
    </div>
    <div id="missionBlue" class="missionCard" role="button" tabindex="0" aria-label="옵티블루 보기">
      <div class="missionNo">03</div>
      <div class="missionTitle">옵티블루 기술</div>
      <div class="missionDesc">카드를 눌러 확인</div>
    </div>
  </div>

  <!-- ✅ OFF일 때 렌즈 뒤쪽 그라데이션 번짐 -->
  <div id="blueBackGlow" aria-hidden="true"></div>

  <!-- ✅ 광선 레이어 -->
  <div id="blueRayLayer" aria-hidden="true">
    <svg id="blueRaySvg" viewBox="0 0 100 100" preserveAspectRatio="none">
      <defs>
        <linearGradient id="beamInGrad" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0" stop-color="rgba(0,200,255,0)"></stop>
          <stop offset="0.35" stop-color="rgba(0,200,255,.55)"></stop>
          <stop offset="0.6" stop-color="rgba(0,200,255,1)"></stop>
          <stop offset="1" stop-color="rgba(0,200,255,.25)"></stop>
        </linearGradient>
        <linearGradient id="beamOutGrad" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0" stop-color="rgba(0,200,255,.25)"></stop>
          <stop offset="0.35" stop-color="rgba(0,200,255,1)"></stop>
          <stop offset="0.75" stop-color="rgba(0,200,255,.55)"></stop>
          <stop offset="1" stop-color="rgba(0,200,255,0)"></stop>
        </linearGradient>
        <filter id="beamGlow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="0.9" result="blur"/>
          <feMerge>
            <feMergeNode in="blur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- ✅ 꺾임 화살표 -->
        <marker id="beamArrow" viewBox="0 0 10 10" refX="8.2" refY="5" markerWidth="6" markerHeight="6" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(0,200,255,.95)"></path>
        </marker>
      </defs>

      <!-- ✅ 입사광 (OFF/ON 공통) -->
      <line id="beamIn" x1="0" y1="50" x2="50" y2="50"
            stroke="url(#beamInGrad)" stroke-width="1.15" stroke-linecap="round"
            filter="url(#beamGlow)" opacity="0.0"></line>

      <!-- ✅ 직진 출사광 (OFF는 100%, ON은 절반 느낌으로 opacity 조절) -->
      <line id="beamOut" x1="50" y1="50" x2="100" y2="50"
            stroke="url(#beamOutGrad)" stroke-width="1.15" stroke-linecap="round"
            filter="url(#beamGlow)" opacity="0.0"></line>

      <!-- ✅ ON일 때: 꺾임(절반 정도) -->
      <line id="beamBend" x1="50" y1="50" x2="25" y2="70"
            stroke="url(#beamOutGrad)" stroke-width="1.15" stroke-linecap="round"
            marker-end="url(#beamArrow)"
            filter="url(#beamGlow)" opacity="0.0"></line>

      <!-- 접점(ON에서만 강조) -->
      <circle id="beamHit" cx="50" cy="50" r="1.1" fill="rgba(255,255,255,.55)" filter="url(#beamGlow)" opacity="0.0"></circle>
    </svg>
  </div>

  <!-- ✅ 블루라이트 on/off 토글 pill (선택형) -->
  <div id="bluePill" aria-label="블루라이트 차단 선택">
    <div id="blueSegOn" class="blueSegBtn">블루라이트 차단 ON</div>
    <div id="blueSegOff" class="blueSegBtn">OFF</div>
  </div>

  <!-- ✅ 블루라이트 설명/미션 -->
  <div id="blueInfo" aria-hidden="true">
    <div id="blueInfoTop">
      <b>블루라이트 <span class="pct">55%</span> 차단</b>
    </div>
    <div id="blueInfoBody">
      아큐브® 오아시스 MAX는 자외선은 물론,
      블루라이트를 55% 차단하여 디지털에 노출된 눈을 보호합니다.
      블루라이트 차단 효과를 위한 "블루그린 틴트"를 확인해주세요.
    </div>
    <div id="blueInfoMission">
      <div class="left" id="blueMissionText">미션: "블루라이트 차단 on" 버튼을 눌러 차이를 비교해 보세요</div>
      <div class="confirm" id="blueMissionConfirm">확인</div>
    </div>
  </div>

  <!-- 두께 그래프 -->
  <div id="thicknessBar" aria-hidden="true">
    <div id="thHeader">
      <div id="thTitle">두께</div>
      <div id="thUnit">mm</div>
    </div>
    <div id="gradRow">
      <div class="tickLabel">얇음_0.0</div>
      <div id="gradWrap">
        <div id="grad"></div>
        <div id="gradShine"></div>
        <div class="mark m0"><strong>0.0</strong></div>
        <div class="mark m25"><strong>0.1</strong></div>
        <div class="mark m50"><strong>0.2</strong></div>
        <div class="mark m75"><strong>0.3</strong></div>
        <div class="mark m100"><strong>0.4</strong></div>
      </div>
      <div class="tickLabel" style="text-align:left;width:46px;">0.4_두껍</div>
    </div>
    <div id="thHint"></div>
  </div>

  <!-- PVP 큰 원형 -->
  <div id="pvpBig">
    <img id="pvpBigImg" src="PVP.gif" alt="PVP Big" onerror="this.onerror=null; this.src='PVP.jpeg';">
  </div>

  <!-- PVP 하단 설명 -->
  <div id="pvpOverlay">
    <img id="pvpThumb" src="PVP.png" alt="PVP" onerror="this.onerror=null; this.src='PVP.jpeg';">
    <div id="pvpText">
      <div id="pvpTitle">PVP 습윤 인자</div>
      <div id="hint">렌즈 내 PVP 습윤인자가 수분을 더 오랫동안 눈물막 유지하여 건조감을 감소 시킵니다.</div>
    </div>
    <div id="pvpConfirm" role="button" tabindex="0" aria-label="확인">확인</div>
  </div>

  <!-- ASD 오버레이 -->
  <div id="asdOverlay" aria-hidden="true">
    <div id="asdCard">
      <button id="asdClose" type="button" aria-label="닫기">✕</button>
      <div id="asdScene">
        <model-viewer
          id="asdEyeMV"
          src="eye_animation.glb"
          camera-orbit="0deg 90deg 0.78m"
          camera-target="0m 0.02m 0m"
          exposure="1.25"
          tone-mapping="aces"
          environment-image="neutral"
          shadow-intensity="0"
          interaction-prompt="none"
          style="display:block;">
        </model-viewer>
        <div id="asdLensRim" aria-hidden="true"></div>
        <img id="asdLensImg" src="lens.png" alt="Lens overlay"
             onerror="this.style.display='none'; document.getElementById('asdHint').textContent='lens.png / lens2.png 파일을 같은 폴더에 넣어주세요.';">
        <div id="asdMaskShade" aria-hidden="true"></div>
        <div id="asdBlinkLid" aria-hidden="true"></div>
        <div id="asdAngleBadge">20°</div>
        <button id="asdRotateBtn" type="button" aria-label="회전">축이탈</button>
        <button id="asdBlinkBtn" type="button" aria-label="눈 깜박">깜박임</button>
      </div>
      <div id="asdHint">미션. ‘깜박임’ 버튼을 눌러 이탈된 축을 안정화 시켜주세요</div>
    </div>
  </div>

  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <script nomodule src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js"></script>

  <model-viewer
    id="mv"
    src="lens_clear.glb"
    camera-controls
    camera-orbit="0deg 100deg 2.6m"
    camera-target="0m 0.015m 0m"
    touch-action="pan-y"
    exposure="1.35"
    tone-mapping="aces"
    environment-image="neutral"
    shadow-intensity="0"
    style="display:block;">
  </model-viewer>

  <div id="bottomBtns">
    <button id="btnReset" title="처음 위치로">↺</button>
    <button id="modeLens" class="btn primary">투명 렌즈 모드</button>
    <button id="modeHeat" class="btn">렌즈 두께 MAP</button>
  </div>

  <script>
    const mv = document.getElementById('mv');

    const missionASD  = document.getElementById('missionASD');
    const missionPVP  = document.getElementById('missionPVP');
    const missionBlue = document.getElementById('missionBlue');

    const modeLens = document.getElementById('modeLens');
    const modeHeat = document.getElementById('modeHeat');

    const btnReset = document.getElementById('btnReset');

    const asdOverlay = document.getElementById('asdOverlay');
    const asdClose   = document.getElementById('asdClose');

    const pvpOverlay = document.getElementById('pvpOverlay');
    const pvpBig     = document.getElementById('pvpBig');
    const pvpConfirm = document.getElementById('pvpConfirm');

    const thicknessBar = document.getElementById('thicknessBar');

    /* ✅ 블루라이트 UI */
    const bluePill = document.getElementById('bluePill');
    const blueSegOn  = document.getElementById('blueSegOn');
    const blueSegOff = document.getElementById('blueSegOff');
    const blueRayLayer = document.getElementById('blueRayLayer');
    const blueBackGlow = document.getElementById('blueBackGlow');
    const blueInfo = document.getElementById('blueInfo');
    const blueMissionText = document.getElementById('blueMissionText');
    const blueMissionConfirm = document.getElementById('blueMissionConfirm');

    const beamIn  = document.getElementById('beamIn');
    const beamOut = document.getElementById('beamOut');
    const beamBend = document.getElementById('beamBend');
    const beamHit = document.getElementById('beamHit');

    /* ✅ ASD 요소 */
    const asdEyeMV = document.getElementById('asdEyeMV');
    const asdLensImg = document.getElementById('asdLensImg');
    const asdBlinkBtn = document.getElementById('asdBlinkBtn');
    const asdRotateBtn = document.getElementById('asdRotateBtn');
    const asdBlinkLid = document.getElementById('asdBlinkLid');
    const asdAngleBadge = document.getElementById('asdAngleBadge');
    const asdLensRim = document.getElementById('asdLensRim');
    const asdHint = document.getElementById('asdHint');

    let currentMode = 'lens'; // 'lens' | 'heat'
    let blueOn = false;
    let pvpOn = false;

    // ✅ PVP 미션 완료 여부
    let pvpDone = false;

    // ✅ 블루라이트 패널 오픈 상태
    let bluePanelOpen = false;

    // 투명/히트맵 전환 시에도 카메라 연동 (유지)
    let lastOrbit = null;
    let lastTarget = null;

    // 디폴트(처음 상태) (유지)
    let defaultOrbit = null;
    let defaultTarget = null;
    let defaultFov = null; // ✅ 최초 fieldOfView 저장 (진짜 줌 리셋용)

    // ✅ 블루 패널 오픈 시 전용 사선 뷰
    const BLUE_PANEL_ORBIT_STR  = '25deg 92deg 2.75m';
    const BLUE_PANEL_TARGET_STR = '0m -0.010m 0m';

    // (유지) 기존 정의는 두되, ON/OFF에서 카메라를 바꾸지 않게 함
    const BLUE_ORBIT_STR  = '-20deg 88deg 2.75m';
    const BLUE_TARGET_STR = '0m -0.010m 0m';

    // ✅ (정리) 1번/2번 디폴트 뷰
    // 1) 투명 렌즈 모드 디폴트 (위치, 크기)
    const CLEAR_DEFAULT_ORBIT_STR  = '0deg 100deg 2.6m';
    const CLEAR_DEFAULT_TARGET_STR = '0m 0.015m 0m';

    // 2) 렌즈 두께 MAP 디폴트 (위치, 크기)
    // 필요하면 여기 숫자만 바꾸면 됨.
    const HEAT_DEFAULT_ORBIT_STR  = '0deg 100deg 2.6m';
    const HEAT_DEFAULT_TARGET_STR = '0m 0.015m 0m';

    // ✅ load 후 "강제로" 디폴트 카메라를 세팅해야 하는 경우를 위한 플래그
    let pendingCameraPreset = null; // {orbitStr, targetStr} | null

    let orbitBeforeBlue = null;
    let targetBeforeBlue = null;

    // 블루그린 톤 (ON 시)
    const BLUEGREEN_TINT = [0.55, 1.08, 0.72, 0.45];

    // 원본 색 백업
    let allMaterialBackup = null;

    // ✅ 미션: ON만 1번 눌러도 성공 + 확인 노출
    const blueMission = {
      successShown: false,
      confirmed: false,
      sawOn: false,
      sawOff: false
    };

    // ✅ 광선 애니메이션(빠르게) - iOS 호환: attribute로 dash 처리
    let beamAnimTimer = null;
    function animateBeamLine(el){
      if(!el) return;

      el.setAttribute('stroke-dasharray', '140');
      el.setAttribute('stroke-dashoffset', '140');

      void el.getBoundingClientRect();

      el.style.transition = 'stroke-dashoffset 260ms linear';
      el.setAttribute('stroke-dashoffset', '0');
    }

    function getOpacity(el){
      const a = el.getAttribute('opacity');
      const s = (el.style && el.style.opacity) ? el.style.opacity : null;
      return parseFloat((s != null && s !== '') ? s : (a != null ? a : '0')) || 0;
    }

    function playBeamAnimation(){
      if(beamAnimTimer) clearTimeout(beamAnimTimer);

      if(getOpacity(beamIn)  > 0) animateBeamLine(beamIn);
      if(getOpacity(beamOut) > 0) animateBeamLine(beamOut);
      if(getOpacity(beamBend)> 0) animateBeamLine(beamBend);

      beamAnimTimer = setTimeout(()=>{
        [beamIn, beamOut, beamBend].forEach(el=>{
          if(!el) return;
          el.style.transition = '';
          el.removeAttribute('stroke-dasharray');
          el.removeAttribute('stroke-dashoffset');
        });
        beamAnimTimer = null;
      }, 320);
    }

    function setBlueUI(){
      const visible = (bluePanelOpen && currentMode === 'lens');

      bluePill.style.display = visible ? 'flex' : 'none';
      blueInfo.style.display = visible ? 'block' : 'none';
      blueInfo.setAttribute('aria-hidden', visible ? 'false' : 'true');

      blueRayLayer.style.display = visible ? 'block' : 'none';
      blueBackGlow.style.display = (visible && !blueOn) ? 'block' : 'none';

      // ✅ 세그먼트 선택 상태 표시
      blueSegOn.classList.toggle('on', blueOn === true);
      blueSegOff.classList.toggle('on', blueOn === false);

      // ✅ 미션: ON만 눌러도 성공 + 확인 노출
      if(blueMission.successShown && !blueMission.confirmed){
        blueMissionText.textContent = '미션 성공: 확인 버튼을 눌러주세요';
        blueMissionConfirm.style.display = 'block';
      }else{
        blueMissionText.textContent = '미션: "블루라이트 차단 on" 버튼을 눌러 차이를 비교해 보세요';
        blueMissionConfirm.style.display = 'none';
      }

      syncBeamVisibility();
      if(visible){
        updateBeams();
        playBeamAnimation();
      }
    }

    function syncBeamVisibility(){
      const visible = (bluePanelOpen && currentMode === 'lens');
      if(!visible){
        beamIn.setAttribute('opacity','0');
        beamOut.setAttribute('opacity','0');
        beamBend.setAttribute('opacity','0');
        beamHit.setAttribute('opacity','0');
        return;
      }

      // OFF: 입사 + 직진 출사 노출
      if(!blueOn){
        beamIn.setAttribute('opacity','0.92');
        beamOut.setAttribute('opacity','0.92');
        beamBend.setAttribute('opacity','0');
        beamHit.setAttribute('opacity','0');
        return;
      }

      // ON: 입사 + 직진(절반) + 반사(짧게) + 접점 강조
      beamIn.setAttribute('opacity','0.92');
      beamOut.setAttribute('opacity','0.55');
      beamBend.setAttribute('opacity','0.55');
      beamHit.setAttribute('opacity','0.90');
    }

    // ✅ 광선 위치 업데이트
    function updateBeams(){
      const visible = (bluePanelOpen && currentMode === 'lens');
      if(!visible) return;

      const rect = mv.getBoundingClientRect();

      // ✅ 중심 보정 + ON일 때 Y축 더 위로
      const baseHitX = rect.left + rect.width * 0.50;
      let   baseHitY = rect.top  + rect.height * 0.54;   // 기본(살짝 아래)
      if(blueOn) baseHitY -= rect.height * 0.06;         // ON: 더 위로

      const hitX = baseHitX;
      const hitY = baseHitY;

      const toVw = (x)=> (x / window.innerWidth) * 100;
      const toVh = (y)=> (y / window.innerHeight) * 100;

      const hx = toVw(hitX), hy = toVh(hitY);

      // 입사광: 왼쪽 → 중심 (수평)
      const inX1 = rect.left - rect.width * 0.25;
      beamIn.setAttribute('x1', toVw(inX1));
      beamIn.setAttribute('y1', hy);
      beamIn.setAttribute('x2', hx);
      beamIn.setAttribute('y2', hy);

      // 직진 출사광: 중심 → 오른쪽 (수평)
      const outX2 = rect.left + rect.width * 1.25;
      beamOut.setAttribute('x1', hx);
      beamOut.setAttribute('y1', hy);
      beamOut.setAttribute('x2', toVw(outX2));
      beamOut.setAttribute('y2', hy);

      // ON일 때 반사광: 짧게 + 위로
      const bendX2 = hitX - rect.width * 0.20;
      const bendY2 = hitY - rect.height * 0.18;
      beamBend.setAttribute('x1', hx);
      beamBend.setAttribute('y1', hy);
      beamBend.setAttribute('x2', toVw(bendX2));
      beamBend.setAttribute('y2', toVh(bendY2));

      beamHit.setAttribute('cx', hx);
      beamHit.setAttribute('cy', hy);
    }

    mv.addEventListener('camera-change', ()=>{
      if(bluePanelOpen && currentMode === 'lens') updateBeams();
    });
    window.addEventListener('resize', ()=>{
      if(bluePanelOpen && currentMode === 'lens') updateBeams();
    });

    /* ✅✅ ASD 로직 (원본 유지) */
    let asdAngle = 20;
    const ASD_STEP = 5;
    const ASD_START = 20;
    let asdLastDir = -1;
    let asdDone = false;

    function setASDHintDefault(){
      if(!asdHint) return;
      asdHint.innerHTML = '미션. ‘깜박임’ 버튼을 눌러 이탈된 축을 안정화 시켜주세요';
    }
    function setASDHintSuccess(){
      if(!asdHint) return;
      asdHint.innerHTML = `
        <span>미션성공 : 축이 안정화되었습니다. 확인 버튼을 눌러주세요</span>
        <button id="asdConfirmBtn" type="button" aria-label="확인">확인</button>
      `;
      const btn = document.getElementById('asdConfirmBtn');
      if(btn){
        btn.addEventListener('click', (e)=>{
          e.stopPropagation();
          closeASD();
          markASDDone(true);
        });
      }
    }
    function markASDDone(done){
      asdDone = !!done;
      missionASD.classList.toggle('done', asdDone);
    }
    function pickASDLensSrc(){
      return (currentMode === 'heat') ? 'lens2.png' : 'lens.png';
    }
    function setASDLensSrc(){
      if(!asdLensImg) return;
      const src = pickASDLensSrc();
      asdLensImg.src = src + '?v=' + Date.now();
    }
    function renderASDLensTransform(extraX=0){
      if(!asdLensImg) return;
      asdLensImg.style.transform = `translate(calc(-50% + ${extraX}px), -50%) rotate(${asdAngle}deg)`;
      if(asdAngleBadge) asdAngleBadge.textContent = `${asdAngle}°`;
    }
    function resetASDState(){
      asdAngle = ASD_START;
      asdLastDir = -1;
      renderASDLensTransform(0);
    }
    function playBlinkLid(){
      if(!asdBlinkLid) return;
      asdBlinkLid.style.transition = 'none';
      asdBlinkLid.style.transform = 'scaleY(0)';
      asdBlinkLid.style.opacity = '0';
      requestAnimationFrame(()=>{
        asdBlinkLid.style.transition = 'transform 120ms ease, opacity 120ms ease';
        asdBlinkLid.style.transform = 'scaleY(1)';
        asdBlinkLid.style.opacity = '0.88';
        setTimeout(()=>{
          asdBlinkLid.style.transition = 'transform 150ms ease, opacity 150ms ease';
          asdBlinkLid.style.transform = 'scaleY(0)';
          asdBlinkLid.style.opacity = '0';
        }, 120);
      });
    }
    function overshootAndReturn(){
      const overshootDeg = asdLastDir * 3;
      if(!asdLensImg) return;
      asdLensImg.style.transition = 'transform 120ms ease';
      asdAngle = overshootDeg;
      renderASDLensTransform(0);
      setTimeout(()=>{
        asdLensImg.style.transition = 'transform 180ms ease';
        asdAngle = 0;
        renderASDLensTransform(0);
        setTimeout(()=>{
          if(asdLensImg) asdLensImg.style.transition = '';
        }, 190);
      }, 120);
    }
    function handleASDBlink(){
      playBlinkLid();
      if(asdAngle > 0){
        asdLastDir = -1;
        asdAngle = Math.max(0, asdAngle - ASD_STEP);
        if(asdLensImg){
          asdLensImg.style.transition = 'transform 160ms ease';
          renderASDLensTransform(0);
          setTimeout(()=>{ if(asdLensImg) asdLensImg.style.transition = ''; }, 170);
        }else{
          renderASDLensTransform(0);
        }
        if(asdAngle === 0 && !asdDone){
          setASDHintSuccess();
        }
      }else if(asdAngle < 0){
        asdLastDir = +1;
        asdAngle = Math.min(0, asdAngle + ASD_STEP);
        if(asdLensImg){
          asdLensImg.style.transition = 'transform 160ms ease';
          renderASDLensTransform(0);
          setTimeout(()=>{ if(asdLensImg) asdLensImg.style.transition = ''; }, 170);
        }else{
          renderASDLensTransform(0);
        }
        if(asdAngle === 0 && !asdDone){
          setASDHintSuccess();
        }
      }else{
        overshootAndReturn();
      }
    }
    if(asdBlinkBtn){
      asdBlinkBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        handleASDBlink();
      });
    }
    function handleASDRotateRandom(){
      markASDDone(false);
      setASDHintDefault();
      const mags = [10,15,20];
      const mag = mags[Math.floor(Math.random() * mags.length)];
      const dir = (Math.random() < 0.5) ? -1 : 1;
      asdLastDir = dir;
      asdAngle = dir * mag;
      if(asdLensImg){
        asdLensImg.style.transition = 'transform 180ms ease';
        renderASDLensTransform(0);
        setTimeout(()=>{ if(asdLensImg) asdLensImg.style.transition = ''; }, 190);
      }else{
        renderASDLensTransform(0);
      }
    }
    if(asdRotateBtn){
      asdRotateBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        handleASDRotateRandom();
      });
    }

    function getOrbitSafe(){ try{ return mv.getCameraOrbit(); }catch(e){ return null; } }
    function getTargetSafe(){ try{ return mv.getCameraTarget(); }catch(e){ return null; } }
    function applyOrbit(orbit){
      if(!orbit) return;
      try{ mv.cameraOrbit = `${orbit.theta}rad ${orbit.phi}rad ${orbit.radius}m`; }catch(e){}
    }
    function applyTarget(target){
      if(!target) return;
      try{ mv.cameraTarget = `${target.x}m ${target.y}m ${target.z}m`; }catch(e){}
    }
    function applyOrbitStr(s){ try{ mv.cameraOrbit = s; }catch(e){} }
    function applyTargetStr(s){ try{ mv.cameraTarget = s; }catch(e){} }

    // ✅ (정리) 모드별 "진짜 최초 디폴트" 복귀 함수 (iOS pinch 줌 잔상까지 제거)
    function resetCameraToModeDefault(mode){
      const orbitStr  = (mode === 'heat') ? HEAT_DEFAULT_ORBIT_STR  : CLEAR_DEFAULT_ORBIT_STR;
      const targetStr = (mode === 'heat') ? HEAT_DEFAULT_TARGET_STR : CLEAR_DEFAULT_TARGET_STR;

      const applyAll = ()=>{
        applyTargetStr(targetStr);
        applyOrbitStr(orbitStr);

        // ✅ pinch 줌 잔상(FOV)까지 리셋
        try{
          if(defaultFov) mv.fieldOfView = defaultFov;
          else mv.fieldOfView = '45deg'; // fallback
        }catch(e){}

        // ✅ 내부 goal 즉시 반영 (지원되는 버전에서만)
        try{ mv.jumpCameraToGoal?.(); }catch(e){}
      };

      // ✅ iOS에서 controls 내부 상태(관성/줌)까지 날리기 위해 토글
      try{ mv.removeAttribute('camera-controls'); }catch(e){}

      applyAll();

      requestAnimationFrame(()=>{
        try{ mv.setAttribute('camera-controls',''); }catch(e){}
        applyAll();
        setTimeout(applyAll, 120);
        setTimeout(applyAll, 260);
      });
    }

    function showPVP(show){
      pvpOverlay.classList.toggle('show', show);
      pvpBig.classList.toggle('show', show);
      // ✅ PVP 확인 버튼: PVP 열릴 때만 노출(완료여부와 무관)
      pvpConfirm.style.display = show ? 'block' : 'none';
    }
    function showThickness(show){
      thicknessBar.classList.toggle('show', show);
      thicknessBar.setAttribute('aria-hidden', show ? 'false' : 'true');
    }

    const PVP_ZOOM_FACTOR = 0.76;
    function zoomInForPVP(){
      try{
        const orbit = getOrbitSafe();
        if(!orbit) return;
        const targetRadius = orbit.radius * PVP_ZOOM_FACTOR;
        mv.cameraOrbit = `${orbit.theta}rad ${orbit.phi}rad ${targetRadius}m`;
      }catch(e){}
    }

    function tuneClearLensMaterials(){
      try{
        const model = mv.model;
        if(!model || !model.materials) return;
        model.materials.forEach(mat=>{
          const pbr = mat.pbrMetallicRoughness;
          if(!pbr) return;
          const base = pbr.baseColorFactor ? [...pbr.baseColorFactor] : [1,1,1,1];
          base[3] = Math.max(base[3], 0.45);
          pbr.setBaseColorFactor(base);
          try{ pbr.setRoughnessFactor(0.28); }catch(e){}
          try{ pbr.setMetallicFactor(0.0); }catch(e){}
          if(mat.extensions && mat.extensions.KHR_materials_transmission){
            mat.extensions.KHR_materials_transmission.transmissionFactor = 0.86;
          }
          try{
            if(mat.emissiveFactor){ mat.emissiveFactor = [0.04, 0.06, 0.07]; }
          }catch(e){}
          try{ if(mat.setAlphaMode) mat.setAlphaMode('BLEND'); }catch(e){}
        });
      }catch(e){}
    }

    function backupOriginalColors(){
      try{
        const model = mv.model;
        if(!model || !model.materials) return;
        allMaterialBackup = model.materials.map(mat=>{
          const pbr = mat.pbrMetallicRoughness;
          const base = (pbr && pbr.baseColorFactor) ? [...pbr.baseColorFactor] : [1,1,1,1];
          return base;
        });
      }catch(e){
        allMaterialBackup = null;
      }
    }
    function restoreOriginalColors(){
      try{
        const model = mv.model;
        if(!model || !model.materials || !allMaterialBackup) return;
        model.materials.forEach((mat, idx)=>{
          const pbr = mat.pbrMetallicRoughness;
          if(!pbr) return;
          const base = allMaterialBackup[idx] ? [...allMaterialBackup[idx]] : [1,1,1,1];
          base[3] = Math.max(base[3], 0.45);
          pbr.setBaseColorFactor(base);
        });
      }catch(e){}
    }
    function applyTint(){
      try{
        const model = mv.model;
        if(!model || !model.materials) return;
        model.materials.forEach((mat, idx)=>{
          const pbr = mat.pbrMetallicRoughness;
          if(!pbr) return;
          const cur = pbr.baseColorFactor ? [...pbr.baseColorFactor] : (allMaterialBackup?.[idx] ? [...allMaterialBackup[idx]] : [1,1,1,1]);
          const a = Math.max(cur[3] ?? 0.45, 0.45);
          pbr.setBaseColorFactor([BLUEGREEN_TINT[0], BLUEGREEN_TINT[1], BLUEGREEN_TINT[2], a]);
        });
      }catch(e){}
    }

    function syncMissionUI(){
      missionASD.classList.toggle('on', asdOverlay.classList.contains('show'));
      missionPVP.classList.toggle('on', pvpOn);
      missionBlue.classList.toggle('on', bluePanelOpen);

      missionASD.classList.toggle('done', asdDone);
      missionBlue.classList.toggle('done', blueMission.confirmed);
      missionPVP.classList.toggle('done', pvpDone);
    }

    function closeASD(){
      asdOverlay.classList.remove('show');
      asdOverlay.setAttribute('aria-hidden','true');
      // ✅ E. ASD 팝업 X -> 1번 디폴트
      resetCameraToModeDefault('lens');
      syncMissionUI();
    }

    function setModeButtons(){
      modeLens.classList.toggle('primary', currentMode === 'lens');
      modeHeat.classList.toggle('primary', currentMode === 'heat');
    }

    function forceBlueOff(){
      blueOn = false;
      restoreOriginalColors();
      orbitBeforeBlue = null;
      targetBeforeBlue = null;
      setBlueUI();
      syncMissionUI();
    }

    function closeBluePanel(){
      bluePanelOpen = false;
      forceBlueOff();
      // (C는 백버튼에서 처리)
      setBlueUI();
      syncMissionUI();
    }

    function forcePVPOff(){
      if(!pvpOn) return;
      pvpOn = false;
      showPVP(false);
      syncMissionUI();
    }

    function openASD(){
      if(bluePanelOpen) closeBluePanel();
      if(pvpOn) forcePVPOff();

      // ✅ ASD 열 때도 1번 디폴트에서 시작
      resetCameraToModeDefault('lens');

      setASDLensSrc();
      resetASDState();
      setASDHintDefault();

      if(asdEyeMV){
        asdEyeMV.src = 'eye_animation.glb' + '?v=' + Date.now();
      }

      asdOverlay.classList.add('show');
      asdOverlay.setAttribute('aria-hidden','false');
      syncMissionUI();
    }

    function setModel(file, mode, options = {}){
      const { resetCamera = false } = options;

      return new Promise((resolve)=>{
        // ✅ 모드 전환 시 "디폴트로 강제" 해야 하는 경우만 preset 지정
        pendingCameraPreset = null;

        // (유지) 기존 상태 저장 로직은 resetCamera=false일 때만
        if(!resetCamera){
          lastOrbit = getOrbitSafe();
          lastTarget = getTargetSafe();
        }else{
          lastOrbit = null;
          lastTarget = null;

          // ✅ 1/2번 디폴트로 세팅 예약
          if(mode === 'heat'){
            pendingCameraPreset = { orbitStr: HEAT_DEFAULT_ORBIT_STR, targetStr: HEAT_DEFAULT_TARGET_STR };
          }else{
            pendingCameraPreset = { orbitStr: CLEAR_DEFAULT_ORBIT_STR, targetStr: CLEAR_DEFAULT_TARGET_STR };
          }
        }

        currentMode = mode;

        forcePVPOff();
        if(bluePanelOpen) closeBluePanel();

        showThickness(mode === 'heat');
        setModeButtons();

        const onLoadOnce = ()=>{
          mv.removeEventListener('load', onLoadOnce);
          resolve();
        };
        mv.addEventListener('load', onLoadOnce, { once:true });

        mv.src = file + '?v=' + Date.now();
      });
    }

    mv.addEventListener('load', ()=>{
      if(!defaultOrbit) defaultOrbit = getOrbitSafe();
      if(!defaultTarget) defaultTarget = getTargetSafe();
      if(!defaultFov){
        try{ defaultFov = mv.fieldOfView; }catch(e){ defaultFov = null; }
      }

      // ✅ (정리) 1/2번 디폴트로 강제하는 경우 우선 적용
      if(pendingCameraPreset){
        applyTargetStr(pendingCameraPreset.targetStr);
        applyOrbitStr(pendingCameraPreset.orbitStr);

        setTimeout(()=>{
          applyTargetStr(pendingCameraPreset.targetStr);
          applyOrbitStr(pendingCameraPreset.orbitStr);
        }, 120);

        // ✅ 로드 직후에도 "하드 리셋" 한 번 더 (iOS 안정화)
        resetCameraToModeDefault(currentMode);

        // 적용 후 해제
        pendingCameraPreset = null;
      }else{
        // (유지) 기존 동작: 모드 전환 시 카메라 유지
        if(lastTarget) applyTarget(lastTarget);
        if(lastOrbit)  applyOrbit(lastOrbit);

        setTimeout(()=>{
          if(lastTarget) applyTarget(lastTarget);
          if(lastOrbit)  applyOrbit(lastOrbit);
        }, 120);
      }

      if(currentMode === 'lens'){
        tuneClearLensMaterials();
        backupOriginalColors();
      }

      setModeButtons();
      setBlueUI();
      syncMissionUI();
    });

    /* ✅ ASD (미션 01 카드 클릭) */
    function toggleASD(){
      if(asdOverlay.classList.contains('show')) closeASD();
      else openASD();
    }
    missionASD.addEventListener('click', toggleASD);
    missionASD.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') toggleASD(); });

    asdClose.addEventListener('click', closeASD);
    asdOverlay.addEventListener('click', (e)=>{ if(e.target === asdOverlay) closeASD(); });

    /* ✅ PVP (미션 02 카드 클릭) */
    async function togglePVP(){
      if(currentMode === 'heat'){
        // ✅ F. 2번 카드 누르면 무조건 "1번 디폴트"로 돌아가서 미션 수행
        await setModel('lens_clear.glb', 'lens', { resetCamera:true });
      }
      if(currentMode !== 'lens') return;

      if(!pvpOn && bluePanelOpen) closeBluePanel();
      if(asdOverlay.classList.contains('show')) closeASD();

      pvpOn = !pvpOn;

      if(pvpOn){
        // ✅ F. PVP 시작은 무조건 1번 디폴트에서 시작
        resetCameraToModeDefault('lens');
        setTimeout(()=>{
          zoomInForPVP();
          showPVP(true);
          syncMissionUI();
        }, 140);
      }else{
        showPVP(false);
        // ✅ PVP 닫을 때도 1번으로 복귀(일관성)
        resetCameraToModeDefault('lens');
        syncMissionUI();
      }
    }
    missionPVP.addEventListener('click', togglePVP);
    missionPVP.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') togglePVP(); });

    /* ✅ PVP 확인 버튼: 디폴트 복귀 + 미션 완료 */
    function confirmPVP(){
      pvpDone = true;
      pvpOn = false;
      showPVP(false);
      // ✅ D. 확인 누르면 1번 디폴트
      resetCameraToModeDefault('lens');
      syncMissionUI();
    }
    pvpConfirm.addEventListener('click', (e)=>{ e.stopPropagation(); confirmPVP(); });
    pvpConfirm.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); confirmPVP(); } });

    /* ✅ 블루 카드: 패널 오픈/클로즈 + 전용 사선 뷰로 즉시 이동 */
    async function toggleBluePanel(){
      if(currentMode === 'heat'){
        // ✅ F. 3번 카드 누르면 무조건 "1번 디폴트"로 돌아가서 미션 수행
        await setModel('lens_clear.glb', 'lens', { resetCamera:true });
      }
      if(currentMode !== 'lens') return;

      forcePVPOff();
      if(asdOverlay.classList.contains('show')) closeASD();

      bluePanelOpen = !bluePanelOpen;

      if(!bluePanelOpen){
        closeBluePanel();
        // ✅ (닫을 때는 렌즈 디폴트로)
        resetCameraToModeDefault('lens');
        return;
      }

      // 패널 오픈 시: 기본 OFF + 전용 사선 뷰
      forceBlueOff();
      bluePanelOpen = true;

      // ✅ 새 세션 초기화 (확인 전이면 성공 상태만 초기화)
      if(!blueMission.confirmed){
        blueMission.successShown = false;
      }

      applyOrbitStr(BLUE_PANEL_ORBIT_STR);
      applyTargetStr(BLUE_PANEL_TARGET_STR);
      setTimeout(()=>{
        applyOrbitStr(BLUE_PANEL_ORBIT_STR);
        applyTargetStr(BLUE_PANEL_TARGET_STR);
        updateBeams();
        playBeamAnimation();
      }, 120);

      setBlueUI();
      syncMissionUI();
    }
    missionBlue.addEventListener('click', toggleBluePanel);
    missionBlue.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') toggleBluePanel(); });

    /* ✅ 블루 상태 설정(카메라 ON/OFF 동일 유지) */
    function setBlueState(nextOn){
      if(!bluePanelOpen) return;

      const newState = !!nextOn;

      // 같은 상태 재클릭이면 애니메이션만
      if(blueOn === newState){
        setBlueUI();
        updateBeams();
        playBeamAnimation();
        return;
      }

      blueOn = newState;

      // ✅ (요청) ON만 눌러도 미션 성공 처리
      if(!blueMission.confirmed && blueOn){
        blueMission.successShown = true;
      }

      // (유지) 기존 변수들
      if(blueOn) blueMission.sawOn = true;
      else blueMission.sawOff = true;

      if(blueOn){
        if(!allMaterialBackup) backupOriginalColors();
        applyTint();
      }else{
        restoreOriginalColors();
      }

      // ✅ ON/OFF 모두 같은 뷰 유지 (OFF 기준)
      applyOrbitStr(BLUE_PANEL_ORBIT_STR);
      applyTargetStr(BLUE_PANEL_TARGET_STR);
      setTimeout(()=>{
        applyOrbitStr(BLUE_PANEL_ORBIT_STR);
        applyTargetStr(BLUE_PANEL_TARGET_STR);
        updateBeams();
        playBeamAnimation();
      }, 80);

      setBlueUI();
      syncMissionUI();
    }

    blueSegOn.addEventListener('click', (e)=>{ e.stopPropagation(); setBlueState(true); });
    blueSegOff.addEventListener('click', (e)=>{ e.stopPropagation(); setBlueState(false); });

    blueMissionConfirm.addEventListener('click', (e)=>{
      e.stopPropagation();
      blueMission.confirmed = true;
      blueMission.successShown = false;
      setBlueUI();
      syncMissionUI();
    });

    /* ✅✅✅ (수정) 백(↺) 버튼: 무조건 "처음 상태(디폴트)"로 초기화 */
    btnReset.addEventListener('click', async ()=>{
      // 1) 미션 전부 OFF
      if(asdOverlay.classList.contains('show')) closeASD();
      if(pvpOn){ pvpOn = false; showPVP(false); }
      if(bluePanelOpen){ bluePanelOpen = false; forceBlueOff(); }

      // 2) 패널류 숨김/표시 (현재 모드 기준)
      showThickness(currentMode === 'heat');
      bluePanelOpen = false;
      setBlueUI();

      // ✅ 핵심: 무조건 현재 모드의 디폴트로 리셋
      resetCameraToModeDefault(currentMode);

      // 5) 미션 카드 UI 동기화
      syncMissionUI();
    });

    /* ✅✅✅ (수정) 모드: 투명 ↔ 두께맵 카메라 연동 유지 */
    modeLens.addEventListener('click', ()=> setModel('lens_clear.glb', 'lens', { resetCamera:false }));
    modeHeat.addEventListener('click', ()=> setModel('lens_heatmap.glb', 'heat', { resetCamera:false }));

    // 초기 (처음 접속만 디폴트 강제)
    setModel('lens_clear.glb', 'lens', { resetCamera:true });
  </script>
</body>
</html>

