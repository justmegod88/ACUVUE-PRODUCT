<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ACUVUE GLB Viewer (Optician)</title>

  <style>
    html,body{height:100%;margin:0;background:#081625;overflow:hidden;font-family:-apple-system,system-ui;}
    model-viewer{width:100vw;height:100vh;background:transparent;display:block;}

    #msg{
      position:fixed;left:12px;right:12px;top:12px;z-index:30;
      padding:10px 12px;border-radius:12px;
      background:rgba(0,0,0,.60);color:#eaf2ff;font-size:13px;line-height:1.35;white-space:pre-wrap;
      border:1px solid rgba(255,255,255,.14);
    }

    #rightBtns{
      position:fixed; right:14px; top:120px; z-index:30;
      display:flex; flex-direction:column; gap:10px;
    }
    .pill{
      width:54px;height:54px;border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#eaf2ff;font-weight:900;font-size:12px;
      display:flex;align-items:center;justify-content:center;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .pill.on{ background:rgba(0,255,140,.14); border-color:rgba(0,255,140,.35); }
    .pill.disabled{ opacity:.35; }

    #bottomBtns{
      position:fixed;left:12px;right:12px;bottom:12px;z-index:30;
      display:flex;gap:8px;flex-wrap:wrap;
    }
    .btn{
      flex:1;min-width:140px;
      padding:12px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#eaf2ff;font-weight:900;font-size:13px;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.primary{ background:rgba(0,255,140,.12); border-color:rgba(0,255,140,.35); }

    #pvpOverlay{
      position:fixed; left:12px; right:12px; bottom:92px; z-index:40;
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px 10px;
      display:none;
      gap:10px;
      align-items:center;
    }
    #pvpOverlay.show{ display:flex; }
    #pvpOverlay img{
      width:88px;height:88px;object-fit:cover;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
    }
    #pvpText{color:#eaf2ff;font-size:12.5px;line-height:1.35;}
    #pvpTitle{font-weight:900;margin-bottom:2px;}
    #hint{opacity:.85;}
  </style>
</head>

<body>
  <div id="msg">준비중…</div>

  <div id="rightBtns">
    <div id="btnBL"  class="pill">BL</div>
    <div id="btnPVP" class="pill">PVP</div>
    <div id="btnBlink" class="pill">순목</div>
  </div>

  <div id="pvpOverlay">
    <img id="pvpImg" src="pvp_inside.jpg" alt="PVP 내부 재질"
      onerror="this.style.display='none'; document.getElementById('pvpText').innerHTML = '<div id=&quot;pvpTitle&quot;>PVP 습윤 인자</div><div id=&quot;hint&quot;>pvp_inside.jpg 파일을 같은 폴더에 넣으면 이미지가 표시돼요.</div>';">
    <div id="pvpText">
      <div id="pvpTitle">PVP 습윤 인자</div>
      <div id="hint">확대 시 렌즈 내부/표면의 습윤 유지 컨셉을 시각적으로 보여줍니다.</div>
    </div>
  </div>

  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <script nomodule src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js"></script>

  <!-- ✅ (핵심) 처음부터 정면을 “목표값”으로 지정 -->
  <model-viewer
    id="mv"
    src="test.glb"
    camera-controls
    camera-target="0m 0m 0m"
    camera-orbit="0deg 90deg 2.6m"
    touch-action="pan-y"
    exposure="1.1"
    shadow-intensity="0"
    style="display:block;">
  </model-viewer>

  <div id="bottomBtns">
    <button id="modeLens" class="btn primary">렌즈(test.glb)</button>
    <button id="modeEye" class="btn">눈(eye_animation.glb)</button>
  </div>

  <script>
    const mv = document.getElementById('mv');
    const msg = document.getElementById('msg');

    const btnBL = document.getElementById('btnBL');
    const btnPVP = document.getElementById('btnPVP');
    const btnBlink = document.getElementById('btnBlink');

    const modeLens = document.getElementById('modeLens');
    const modeEye  = document.getElementById('modeEye');

    const pvpOverlay = document.getElementById('pvpOverlay');

    let currentMode = 'lens'; // 'lens' | 'eye'
    let blOn = false;
    let pvpOn = false;

    let baseRadius = null;

    const BL_TEAL = [0.0, 0.72, 0.70, 1.0];
    let originalBaseColor = null;

    // ✅ 정면 고정값
    const FRONT_THETA_DEG = 0;
    const FRONT_PHI_DEG   = 90;

    // ✅ 순목 1회 재생 보장용(ios finished 미발생 대비)
    let blinkGuardTimer = null;

    function setMsg(t){ msg.textContent = t; }

    function setBtnState(){
      if(currentMode === 'lens'){
        btnBL.classList.remove('disabled');
        btnPVP.classList.remove('disabled');
        btnBlink.classList.add('disabled');
      } else {
        btnBL.classList.add('disabled');
        btnPVP.classList.add('disabled');
        btnBlink.classList.remove('disabled');
      }
    }

    function setModeUI(){
      if(currentMode === 'lens'){
        modeLens.classList.add('primary');
        modeEye.classList.remove('primary');
      } else {
        modeEye.classList.add('primary');
        modeLens.classList.remove('primary');
      }
      setBtnState();
    }

    // ✅ (1) 렌즈/눈 모두 “처음 정면” 강제
    function forceFrontView(){
      try{
        // 사용자 회전 잔상 제거(지원되는 버전이면)
        if (typeof mv.resetTurntableRotation === 'function') mv.resetTurntableRotation();

        // target을 원점으로
        mv.cameraTarget = '0m 0m 0m';

        // radius는 현재값을 쓰되, 없으면 기본값
        let r = 2.6;
        try{
          const orbit = mv.getCameraOrbit();
          if (orbit && orbit.radius) r = orbit.radius;
        }catch(e){}

        mv.cameraOrbit = `${FRONT_THETA_DEG}deg ${FRONT_PHI_DEG}deg ${r}m`;
      }catch(e){}
    }

    async function setModel(file, mode){
      currentMode = mode;

      blOn = false;
      pvpOn = false;
      btnBL.classList.remove('on');
      btnPVP.classList.remove('on');
      pvpOverlay.classList.remove('show');
      originalBaseColor = null;
      baseRadius = null;

      // 순목 타이머 정리
      if (blinkGuardTimer){ clearInterval(blinkGuardTimer); blinkGuardTimer = null; }

      setModeUI();
      setMsg(`로딩중…\n${file}`);

      mv.src = file + '?v=' + Date.now();
    }

    // ✅ 순목이 끝나면 0초로 복귀 (가능할 때)
    mv.addEventListener('finished', ()=>{
      if(currentMode !== 'eye') return;
      try{
        mv.pause();
        mv.currentTime = 0;
      }catch(e){}
      if (blinkGuardTimer){ clearInterval(blinkGuardTimer); blinkGuardTimer = null; }
    });

    mv.addEventListener('load', async ()=>{
      // 줌 기준 반경 저장
      try{
        const orbit = mv.getCameraOrbit();
        baseRadius = orbit.radius;
      }catch(e){ baseRadius = null; }

      // ✅ 로드 직후 정면 강제(타이밍 이슈 대비 2번)
      forceFrontView();
      setTimeout(forceFrontView, 250);

      if(currentMode === 'eye'){
        // 자동 재생 방지 + 정지 상태로 시작
        try{
          mv.loop = false;
          mv.pause();
          mv.currentTime = 0;

          // 애니메이션 이름이 여러개면 첫번째 고정
          if (mv.availableAnimations && mv.availableAnimations.length){
            mv.animationName = mv.availableAnimations[0];
          }
        }catch(e){}
        setMsg('✅ 로드 성공!\n순목 버튼을 눌러야 깜박입니다.');
      } else {
        setMsg('✅ 로드 성공!\n드래그 회전 / 핀치 확대');
      }

      // 렌즈 재질 원색 저장
      if(currentMode === 'lens'){
        try{
          const model = mv.model;
          if(model && model.materials && model.materials.length){
            const mat = model.materials[0];
            const pbr = mat.pbrMetallicRoughness;
            if(pbr && pbr.baseColorFactor){
              originalBaseColor = [...pbr.baseColorFactor];
            }
          }
        }catch(e){}
      }
    });

    mv.addEventListener('error', (e)=>{
      setMsg('❌ 로딩 실패\n' + JSON.stringify(e.detail || {}, null, 2));
    });

    // BL
    btnBL.addEventListener('click', ()=>{
      if(currentMode !== 'lens') return;

      blOn = !blOn;
      btnBL.classList.toggle('on', blOn);

      try{
        const model = mv.model;
        if(!model || !model.materials || !model.materials.length){
          setMsg('⚠️ 재질을 찾지 못했어요(모델 materials 없음).');
          return;
        }
        const mat = model.materials[0];
        const pbr = mat.pbrMetallicRoughness;
        if(!pbr) return;

        if(!originalBaseColor && pbr.baseColorFactor) originalBaseColor = [...pbr.baseColorFactor];
        pbr.setBaseColorFactor(blOn ? BL_TEAL : (originalBaseColor || [1,1,1,1]));

        setMsg(blOn ? 'BL ON: 렌즈 색상을 블루그린 톤으로 표시' : 'BL OFF: 렌즈 색상을 원래대로 복원');
      }catch(err){
        setMsg('❌ BL 적용 실패\n' + (err?.message || err));
      }
    });

    // PVP
    function showPVPOverlay(show){
      pvpOverlay.classList.toggle('show', show);
    }

    function zoomInForPVP(){
      try{
        const orbit = mv.getCameraOrbit();
        const targetRadius = orbit.radius * 0.62;
        mv.cameraOrbit = `${orbit.theta}rad ${orbit.phi}rad ${targetRadius}m`;
      }catch(e){}
    }

    btnPVP.addEventListener('click', ()=>{
      if(currentMode !== 'lens') return;

      pvpOn = !pvpOn;
      btnPVP.classList.toggle('on', pvpOn);

      if(pvpOn){
        zoomInForPVP();
        showPVPOverlay(true);
        setMsg('PVP: 확대 + 내부 재질 오버레이 표시');
      }else{
        showPVPOverlay(false);
        setMsg('PVP: 오버레이 숨김');
      }
    });

    mv.addEventListener('camera-change', ()=>{
      if(currentMode !== 'lens') return;
      try{
        if(!baseRadius) return;
        const orbit = mv.getCameraOrbit();
        const nearEnough = orbit.radius < baseRadius * 0.68;

        if(nearEnough){
          showPVPOverlay(true);
        } else if(!pvpOn){
          showPVPOverlay(false);
        }
      }catch(e){}
    });

    // ✅ (2) 순목 버튼 = “클릭할 때마다 1회만” + 자동 정지 + 다시 클릭하면 또 1회
    btnBlink.addEventListener('click', ()=>{
      if(currentMode !== 'eye') return;

      try{
        // 기존 가드 타이머 정리
        if (blinkGuardTimer){ clearInterval(blinkGuardTimer); blinkGuardTimer = null; }

        mv.loop = false;

        // 애니메이션 지정(있다면)
        if (mv.availableAnimations && mv.availableAnimations.length){
          mv.animationName = mv.availableAnimations[0];
        }

        // 무조건 처음부터
        mv.pause();
        mv.currentTime = 0;

        // iOS에서 play 씹힘 방지
        requestAnimationFrame(()=>{
          mv.play();
          setMsg('순목(1회) 재생');

          // ✅ finished 이벤트가 안 오는 경우 대비: duration 기준 강제 종료
          blinkGuardTimer = setInterval(()=>{
            try{
              const d = mv.duration;
              if (!d || !isFinite(d)) return;

              // 거의 끝까지 가면 강제 stop + reset
              if (mv.currentTime >= d - 0.03){
                mv.pause();
                mv.currentTime = 0;
                clearInterval(blinkGuardTimer);
                blinkGuardTimer = null;
              }
            }catch(e){}
          }, 50);
        });
      }catch(err){
        setMsg('❌ 순목 재생 실패\n(eye_animation.glb에 애니메이션이 없을 수 있어요)');
      }
    });

    modeLens.addEventListener('click', ()=> setModel('test.glb', 'lens'));
    modeEye.addEventListener('click',  ()=> setModel('eye_animation.glb', 'eye'));

    setModeUI();
    setModel('test.glb', 'lens');
  </script>
</body>
</html>
